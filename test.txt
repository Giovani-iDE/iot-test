use rumqttc::{Client, Event, Incoming, MqttOptions, QoS, TlsConfiguration, Transport};
use rustls::{ClientConfig, RootCertStore};
use rustls_pemfile::certs;
use rustls_pki_types::CertificateDer;
use std::fs::File;
use std::io::BufReader;
use std::sync::Arc;
use std::time::Duration;
use std::error::Error;

fn main() -> Result<(), Box<dyn Error>> {
    println!("üöÄ Iniciando cliente MQTT con certificados correctos...");
   
    // ‚úÖ CAMBIO: Leer el certificado de la CA (no el del servidor)
    let cert_file = File::open("./bin/ca.crt")?;  // ‚Üê CAMBIO AQU√ç
    let mut reader = BufReader::new(cert_file);
    
    // Leer certificados y convertir a CertificateDer
    let certs_vec: Vec<CertificateDer<'static>> = certs(&mut reader)
        .collect::<Result<Vec<_>, _>>()?;
    
    if certs_vec.is_empty() {
        return Err("No se encontraron certificados en el archivo".into());
    }
    
    println!("‚úÖ Certificado CA cargado desde ./bin/ca.crt");
    
    // Crear RootCertStore y a√±adir el certificado de la CA
    let mut root_cert_store = RootCertStore::empty();
    for cert in certs_vec {
        root_cert_store.add(cert)?;
    }
    
    println!("‚úÖ Certificado CA a√±adido al almac√©n de confianza");
    
    // Crear configuraci√≥n TLS CON validaci√≥n de certificados
    let client_config = ClientConfig::builder()
        .with_root_certificates(root_cert_store)
        .with_no_client_auth();
    
    let tls_config = TlsConfiguration::Rustls(Arc::new(client_config));
    println!("‚úÖ Configuraci√≥n TLS creada CON validaci√≥n de certificados");
    
    // Configure MQTT options
    let mut mqtt_options = MqttOptions::new("rust-mqtt-client", "192.168.18.22", 8883);
    mqtt_options.set_transport(Transport::Tls(tls_config));
    mqtt_options.set_keep_alive(Duration::from_secs(30));
   
    println!("‚úÖ Opciones MQTT configuradas:");
    println!("   - Host: 192.168.18.22");
    println!("   - Puerto: 8883 (TLS)");
    println!("   - Cliente ID: rust-mqtt-client");
    println!("   - Validaci√≥n de certificados: HABILITADA");
    println!("   - CA de confianza: ./bin/ca.crt");
    
    let (client, mut connection) = Client::new(mqtt_options, 10);
    println!("‚úÖ Cliente MQTT creado");
   
    // Intentar suscribirse
    match client.subscribe("esp32/sensors", QoS::AtLeastOnce) {
        Ok(_) => println!("‚úÖ Suscripci√≥n enviada al t√≥pico: esp32/sensors"),
        Err(e) => println!("‚ùå Error al suscribirse: {}", e),
    }
    
    println!("üîå Esperando mensajes...");
    println!("üîê Usando conexi√≥n TLS con validaci√≥n REAL de certificados");
    
    for event in connection.iter() {
        match event {
            Ok(Event::Incoming(Incoming::Publish(p))) => {
                println!("üì© {} => {}", p.topic, String::from_utf8_lossy(&p.payload));
            }
            Ok(Event::Incoming(Incoming::ConnAck(_))) => {
                println!("‚úÖ Conexi√≥n TLS establecida y certificado VALIDADO");
            }
            Ok(Event::Incoming(Incoming::SubAck(_))) => {
                println!("‚úÖ Suscripci√≥n confirmada");
            }
            Ok(Event::Incoming(Incoming::PingResp)) => {
                println!("üèì Ping response recibido");
            }
            Ok(Event::Outgoing(_)) => {
                // Eventos salientes, no los mostramos para evitar spam
            }
            Ok(other) => {
                println!("üì® Evento recibido: {:?}", other);
            }
            Err(e) => {
                println!("‚ùå Error de conexi√≥n TLS: {}", e);
                println!("üí° Verificar que el servidor est√© usando los certificados correctos");
                break;
            }
        }
    }
    
    Ok(())
}
